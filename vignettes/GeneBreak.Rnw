%\VignetteIndexEntry{GeneBreak}
%\VignetteDepends{GeneBreak}
%\VignetteKeywords{Recurrent gene break detection on copy number data from array-CGH or sequencing.}
%\VignettePackage{GeneBreak}
%\VignetteEngine{utils::Sweave}

\documentclass{article}

\usepackage[colorlinks=true,linkcolor=black,citecolor=black,urlcolor=blue]{
  hyperref}

\begin{document}
\SweaveOpts{concordance=TRUE}

\newcommand{\pkg}[1]{\texttt{#1}}
\newcommand{\code}[1]{\texttt{#1}}

\title{Introduction to GeneBreak}
\author{Evert van den Broek\footnote{email@email.com} \cr\& Stef van Lieshout}
\maketitle
\begin{center}
  Department of Pathology \\*
  VU University Medical Center \\*
  The Netherlands, Amsterdam \\*
\end{center}

\tableofcontents

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Running GeneBreak}

This is a short tutorial on how to use the \pkg{GeneBreak} package. It describes an example workflow which uses included copy number aberration (CNA) data obtained by CGHcall analysis of 200 array-CGH (Agilent 180k) samples from advanced colorectal cancers. Let's start by loading the package.

<<loadingPackage>>=
library(GeneBreak)
@

<<settingOptions,echo=FALSE>>=
options("GeneBreak::verbose"=NA)
options(width=40)
@

\subsection{Detect breakpoints from copy-number data}

Copy number data can be loaded in two ways. We recommend the usage of bioconductor packages \code{CGHcall} or \code{QDNAseq} to process CNA data from array-CGH or sequencing data respectively. The obtained cghCall/QDNAseq object can directly serve as input for the GeneBreak pipeline. Alternatively, a data.frame with exactly these five columns: "Chromosome", "Start", "End" and "FeatureName" (usually probe or bin identifier) followed by columns with sample data can be provided. Note: the first five column names of the data.frame must be similar! In this tutorial we will use a built-in dataset that only contains CNA data from chromosome 20:

%------------------------------------------------------------
\subsubsection{Loading cghCall object}
%------------------------------------------------------------

<<loadingCopynumberData>>=
data( "copynumber.data.chr20" )
@

Inspection of the loaded data shows that we are dealing with an R object of class \code{cghCall} with 3653 features (array-CGH probes in this case) and 200 samples.

<<displayCopynumberData>>=
copynumber.data.chr20
@

To generate an object of class \code{CopyNumberBreakpoints} with breakpoint locations, run \code{getBreakpoints()}. This will obtain the required information from the \code{cghCall} object and determine the breakpoint locations.

<<getBreakpoints>>=
breakpoints <- getBreakpoints( data = copynumber.data.chr20 )
@

%------------------------------------------------------------
\subsubsection{Loading data from a dataframe}
%------------------------------------------------------------

There is a possibilty of using a \code{data.frame()} as input for \code{GeneBreak}. This allows  breakpoint analysis of data from any copy number detection pipeline by importing a text file into \code{getBreakpoints()}.

Here we show how to use two data.frames() with segment and (optionally) call values as input for \code{getBreakpoints} instead of a cghCall/QDNAseq object.

<<getBreakpointsAlternative, eval=FALSE>>=
library(CGHcall)
cgh <- copynumber.data.chr20

segmented <- data.frame( Chromosome=chromosomes(cgh), Start=bpstart(cgh),
 End=bpend(cgh), FeatureName=featureNames(cgh), segmented(cgh))
called <- data.frame( Chromosome=chromosomes(cgh), Start=bpstart(cgh),
 End=bpend(cgh), FeatureName=featureNames(cgh), calls(cgh))

breakpoints <- getBreakpoints( data = segmented, data2 = called )
@

%------------------------------------------------------------
\subsection{Breakpoint selection by filtering}
%------------------------------------------------------------

Next breakpoints can be filtered by stringent criteria. Different filters can be set (see \code{?bpFilter} for more details). Default setting is "CNA-ass" which means that breakpoints flanked by copy number neutral segments will be filtered out. Note: you need discrete copy number calls (loss,neutral, gain, etc) for this option.

<<bpFilter>>=
breakpointsFiltered <- bpFilter( breakpoints, filter = "CNA-ass" )
@

%------------------------------------------------------------
\subsection{Identification of genes affected by breakpoints}
%------------------------------------------------------------

This describes the two steps needed to identify genes affected by breakpoints by the \pkg{GeneBreak} package.

%------------------------------------------------------------
\subsubsection{Loading gene annotation data}
%------------------------------------------------------------

We need to load gene annotations to be able to identify genes affected by breakpoints in the next step. Gene annotation for human reference genome hg18 (and hg19, hg38) are built-in, but also user-defined annotations can be used. The required columns for this data.frame are "Gene", "Chromosome", "Start" and "End".

<<loadingAnnotation>>=
data( "ens.gene.ann.hg18" )
@

This shows the contents of the hg18 gene annotation dataframe:

\begin{Schunk}
\begin{Sinput}
> head( ens.gene.ann.hg18 )
      Gene           EnsID Chromosome  Start    End   band strand
MIRN1302-2 ENSG00000221311          1  20229  20366 p36.33      1
   FAM138E ENSG00000222027          1  24417  25944 p36.33     -1
   FAM138E ENSG00000222003          1  24417  25944 p36.33     -1
   FAM138A ENSG00000222003          1  24417  25944 p36.33     -1
     OR4F5 ENSG00000177693          1  58954  59871 p36.33      1
    OR4F29 ENSG00000177799          1 357522 358460 p36.33      1
\end{Sinput}
\end{Schunk}

%------------------------------------------------------------
\subsubsection{Detection of gene-associated breakpoints}
%------------------------------------------------------------

Here, the loaded gene annotation information will be added to the GeneBreak object and feature-to-gene mapping will be performed.

<<addGeneAnnotation>>=
breakpointsAnnotated <- addGeneAnnotation( breakpointsFiltered, ens.gene.ann.hg18 )
@

Added labels describe gene position with respect to feature positions:
   A: genes located upstream of the first chromosomal feature (no gene-associated features)
   B: genes located downstream of the last chromosomal feature (no gene-associated features)
   C: the whole gene is located between two features (in case of array-CGH probes)
   C: the whole gene is located between start and end of one bin (in case of sequencing data)
   D: gene represented by one or multiple features
   E: gene represented by one or multiple features, but the end of the gene is not covered by any feature
   X: no feature covers the chromosome of the gene


Next, gene-associated breakpoints will be identified.

<<bpGenes>>=
breakpointGenes <- bpGenes( breakpointsAnnotated )
@

%------------------------------------------------------------
\subsection{Cohort-based breakpoint statistics}
%------------------------------------------------------------

Following identification of (gene) breakpoints per profile, breakpoint events that are significantly recurring will be determined by dedicated statistical analysis. This can be performed at "gene" (breakpoint gene) and/or "feature" (breakpoint location) level. Two different methods of FDR-type correction for multiple testing can be used, the standard Benjamini-Hochberg FDR-type correction ("BH") or dedicated Benjamini-Hochberg FDR-type correction ("Gilbert").

%------------------------------------------------------------
\subsubsection{Detection of recurrent breakpoint genes}
%------------------------------------------------------------

The gene-based statistical analysis includes correction for covariates that may influence the probability to be a breakpoint gene including number of breakpoints in a profile, number of gene-associated features and gene length by gene-associated feature coverage. Multiple testing can be applied by the powerful dedicated Benjamini-Hochberg FDR-type correction ("Gilbert") that accounts for the discreteness of the null-distribution.
NOTE: when running \code{bpStats()} warnings can be generated by a function (glm.fit) of a dependancy package, this does not harm the analysis.

<<bpStats>>=
breakpointStatistics <- bpStats( breakpointGenes, level = "gene", method = "Gilbert" )
@


This will return an object of class \code{CopyNumberBreakPointGenes}.

By using \code{recurrentGenes()} we can observe the recurrent affected genes.

<<recurrentGenes>>=
head( recurrentGenes( breakpointStatistics ) )
@

%------------------------------------------------------------
\subsubsection{Detection of recurrent breakpoint locations}
%------------------------------------------------------------

With this step, statistics at breakpoint location (feature) level will be added to the object of class \code{CopyNumberBreakPointGenes}. Here, we recommend to use the less computationally intensive standard Benjamini-Hochberg FDR-type correction for multiple testing, because the breakpoint probability is equal across features per profile, which means that all positions correspond to the same null-distribution. 

<<bpStats>>=
breakpointStatistics <- bpStats( 
  breakpointStatistics, level = "feature", method = "BH" )
@


<<showStatsObject,eval=TRUE>>=
breakpointStatistics
@

%------------------------------------------------------------
\subsection{Visualization of breakpoint frequencies}
%------------------------------------------------------------

Breakpoint locations and frequencies can be visualized using this function:

<<echo=FALSE>>=
png("bpPlot.png")
@
<<label=bpPlot>>=
bpPlot( breakpointStatistics, fdr.threshold = 0.1 )
@
<<echo=FALSE, results=hide>>=
dev.off()
@

\begin{figure}[h]
  \centering
  \includegraphics{bpPlot}
  \caption{Graphical representation of CNA-associated chromosomal breakpoint frequencies and their distribution over chromosomes 20. The X-axis depicts the genomic position in Mb. The Y-axis depicts the chromosomal breakpoint frequencies across the series of 200 CRC samples. Breakpoint frequencies are indicated on array-CGH probe-level (vertical black bars) and on gene-level (horizontal red bars). Recurrent breakpoint genes (FDR<0.1) are named. When the gene breakpoint frequency exceeded 15\% (horizontal dashed line), the breakpoint frequency (\%) follows the gene name.}
  \label{fig:bpPlot}
\end{figure}


\clearpage

\section{Storage of R objects}
At any time during the analysis, the GeneBreak objects (and any R objects for that matter) can be saved to disk with:
\code{saveRDS}, and in the future be read from the local file with
\code{loadRDS}

\section{Downloading Gene Annotations}

This section describes the steps taken to create the gene annotations used in this package. It may serve as a start for creating your own if required for whatever reason.

<<createAnnotationExample,eval=FALSE>>=
# gene annotations obtained via Biomart. 
# HUGO gene names (HGNC symbol), Ensembl_ID and chromosomal location

# Used (and most) recent releases:
# HG18: release54
# HG19: release75
# HG38: release80 (date: 150629)

library(biomaRt)

ensembl54 = useMart( 
  host = 'may2009.archive.ensembl.org', 
  biomart = 'ENSEMBL_MART_ENSEMBL', 
  dataset = "hsapiens_gene_ensembl" 
)
ensembl75 = useMart( 
  host = 'feb2014.archive.ensembl.org', 
  biomart = 'ENSEMBL_MART_ENSEMBL', 
  dataset = "hsapiens_gene_ensembl" 
)
ensembl80 = useMart( 
  "ensembl", 
  dataset = "hsapiens_gene_ensembl" 
)

createAnnotationFile <- function( biomartVersion ) {
  biomart_result <- getBM( 
    attributes =  c( 
      "hgnc_symbol", "ensembl_gene_id", "chromosome_name",  
      "start_position", "end_position", "band", "strand" 
    ), 
    mart = biomartVersion
  )

  biomart_result[ ,3] <- as.vector( biomart_result[ ,3] )
  idx_x <- biomart_result$chromosome_name == "X"
  idx_y <- biomart_result$chromosome_name == "Y"
  biomart_result$chromosome_name[ idx_x ] <- "23"
  biomart_result$chromosome_name[ idx_y ] <- "24"
  
  biomart_genes <- biomart_result[ which(biomart_result[ ,1] != "" & 
    biomart_result[ ,3] %in% c(1:24)) , ]
  colnames(biomart_genes)[1:5] <- c("Gene","EnsID","Chromosome","Start","End")
  
  cat( 
    c( "Biomart version:", biomartVersion@host, 
          "including:", dim(biomart_genes)[1], "genes\n"
    )
  ) 
  
  return( biomart_genes )
}

ens.gene.ann.hg18 <- createAnnotationFile( ensembl54 )
ens.gene.ann.hg19 <- createAnnotationFile( ensembl75 )
ens.gene.ann.hg38 <- createAnnotationFile( ensembl80 )

@

\clearpage

\section{Session Information}

The version number of R and packages loaded for generating the vignette were:

<<sessionInfo,echo=FALSE>>=
sessionInfo()
@

\end{document}

% EOF
